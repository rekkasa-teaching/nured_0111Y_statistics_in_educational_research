<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>chapter-01 – Στατιστική στην εκπαιδευτική έρευνα</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-2d5effa1089c490eac5c05282fa1a5ea.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Στατιστική στην εκπαιδευτική έρευνα</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Αρχική</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../slides-index.html"> 
<span class="menu-text">Παρουσιάσεις</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../notes-index.html"> 
<span class="menu-text">Σημειώσεις</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Περιεχόμενα</h2>
   
  <ul>
  <li><a href="#βασικές-στατιστικές-έννοιες" id="toc-βασικές-στατιστικές-έννοιες" class="nav-link active" data-scroll-target="#βασικές-στατιστικές-έννοιες">Βασικές στατιστικές έννοιες</a>
  <ul>
  <li><a href="#πληθυσμός-και-δείγμα" id="toc-πληθυσμός-και-δείγμα" class="nav-link" data-scroll-target="#πληθυσμός-και-δείγμα">Πληθυσμός και δείγμα</a></li>
  <li><a href="#μεταβλητές" id="toc-μεταβλητές" class="nav-link" data-scroll-target="#μεταβλητές">Μεταβλητές</a></li>
  <li><a href="#κλίμακες-μέτρησης-μεταβλητών" id="toc-κλίμακες-μέτρησης-μεταβλητών" class="nav-link" data-scroll-target="#κλίμακες-μέτρησης-μεταβλητών">Κλίμακες μέτρησης μεταβλητών</a></li>
  <li><a href="#μαθηματικοί-συμβολισμοί" id="toc-μαθηματικοί-συμβολισμοί" class="nav-link" data-scroll-target="#μαθηματικοί-συμβολισμοί">Μαθηματικοί συμβολισμοί</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="βασικές-στατιστικές-έννοιες" class="level1">
<h1>Βασικές στατιστικές έννοιες</h1>
<p>Η έρευνα στην εκπαίδευση κατά ένα πολύ σημαντικό μέρος της περιλαμβάνει τη συλλογή πληροφοριών. Συνήθως, με τη λήξη συλλογής της πληροφορίας οι ερευνητές/τριες καταλήγουν με έναν τεράστιο όγκο μετρήσεων είτε, παλιότερα, σε χαρτί είτε σήμερα σε ηλεκτρονική μορφή. Για την επεξεργασία και αξιοποίηση αυτής της πληροφορίας χρησιμοποιούνται μέθοδοι που συνοπτικά αποκαλούμε “στατιστική”. Η στατιστική μπορεί να χρησιμοποιηθεί τόσο για την οργάνωση και τη συνόψιση της συγκεντρωμένης πληροφορίας όσο και για την συστηματική κατασκευή μίας ερμηνείας της κατάστασης από την οποία η πληροφορία αυτή προέκυψε.</p>
<section id="πληθυσμός-και-δείγμα" class="level2">
<h2 class="anchored" data-anchor-id="πληθυσμός-και-δείγμα">Πληθυσμός και δείγμα</h2>
<p>Κατά την εκτέλεση μίας μελέτης ο/η ερευνητής/τρια ξεκινά διατυπώνοντας ένα γενικό ερώτημα για μία συγκεκριμένη ομάδα ανθρώπων που τον/την ενδιαφέρουν. Με στατιστικούς όρους, το σύνολο όλων των ατόμων ενδιαφέροντος μίας μελέτης ονομάζεται <em>πληθυσμός</em>. Για παράδειγμα, πληθυσμός σε μία εκπαιδευτική έρευνα θα μπορούσε να είναι όλοι οι μαθητές νηπιαγωγείων της Δυτικής Μακεδονίας.</p>
<p>Προφανώς, σε μία μελέτη είναι πολύ δύσκολο να συλλεχθούν οι απαιτούμενες πληροφορίες για το σύνολο του πληθυσμού ενδιαφέροντος, καθώς, τις περισσότερες φορές, αυτός μπορεί να είναι απαγορευτικά μεγάλος. Οπότε, η αμέσως καλύτερη προσέγγιση είναι να χρησιμοποιηθεί ένα υποσύνολο του πληθυσμού, με την ελπίδα ότι αυτό θα “μοιάζει” με τον πληθυσμό. Ένα τέτοιο υποσύνολο ονομάζεται <em>δείγμα</em>. Με στατιστικούς όρους, <em>δείγμα</em> ονομάζεται ένα σύνολο ατόμων το οποίο διαλέχτηκε από τον πληθυσμό με στόχο να τον αντιπροσωπεύσει σε μία ανάλυση.</p>
<p>Μία μελέτη εκπαιδευτικής έρευνας στοχεύει να περιγράψει ή να βγάλει συμπεράσματα για συγκεκριμένα χαρακτηριστικά του πληθυσμού. Τα χαρακτηριστικά αυτά πρέπει να είναι επακριβώς καθορισμένα και μετρήσιμα. Στη στατιστική, τα χαρακτηριστικά αυτά αποκαλούνται <em>παράμετροι</em>. Επομένως, <em>παράμετρος</em> είναι ένα χαρακτηριστικό του πληθυσμού, άγνωστο αλλά μετρήσιμο.</p>
<p>Καθώς η γνώση της τιμής μιας παραμέτρου συνήθως απαιτεί τη λήψη μετρήσεων από το σύνολο του πληθυσμού — πράγμα συνήθως αδύνατο — κατά την εκτέλεση στατιστικών αναλύσεων αρκούμαστε στην εξαγωγή εκτιμήσεων για αυτήν την τιμή με την αξιοίηση του δείγματος. Η <em>εκτίμηση</em> της τιμής μιας παραμέτρου υπολογίζεται συνήθως με τον συνδυασμό των μετρήσεων του δείγματος (π.χ. άθροισμα, μέσος όρος). Με τη χρήση στατιστικής ορολογίας, ένας μαθηματικός συνδυασμός των μετρήσεων ενός δείγματος από τον πληθυσμό ενδιαφέροντος ονομομάζεται <em>στατιστικό</em> ή <em>στατιστική συνάρτηση</em> ή <em>δειγματοσυνάρτηση</em>.</p>
</section>
<section id="μεταβλητές" class="level2">
<h2 class="anchored" data-anchor-id="μεταβλητές">Μεταβλητές</h2>
<p><em>Μεταβλητή</em> είναι οποιοδήποτε μετρήσιμο χαρακτηριστικό ατόμων ή πραγμάτων το οποίο μπορεί να παίρνει διαφορετικές τιμές. Σε αντίθεση, μία <em>σταθερά</em> είναι ένα χαρακτηριστικό το οποίο πάιρνει μία και μοναδική τιμή σε ολόκληρο τον πληθυσμό. Οι σταθερές, αν και φαίνεται ότι δεν έχουν ιδιαίτερο ενδιαφέρον, στην πραγαμτικότητα αντικατοπτρίζουν τις αποφάσεις του ερευνητή/τριας για περιορισμό του πληθυσμού ενδιαφέροντος. Για παράδειγμα, σε μία μελέτη με στόχο το σύνολο των <em>μαθητριών</em> στα νηπιαγωγεία της Δυτικής Μακεδονίας το φύλο είναι μία σταθερά.</p>
<p>Οι μεταβλητές μπορούν να χωριστούν σε δύο κατηγορίες ανάλογα με τις τιμές που μπορούν να λάβουν:</p>
<ul>
<li>Οι <em>διακριτές μεταβλητές</em> παίρνουν τιμές μέσα από ένα σύνολο αδιαίρετων κατηγοριών πλήρως διαχωρίσιμων μεταξύ τους (π.χ. επίπεδο εκπαίδευσης γονέων, δήμος κατοικίας μαθητή, πλήθος μαθητών σε μία τάξη).</li>
<li>Οι <em>συνεχείς μεταβλητές</em> μπορούν να πάρουν οποιαδήποτε τιμή μέσα σε ένα σύνολο. Μεταξύ δύο πιθανών τιμών μίας συνεχούς μεταβλητής υπάρχει άπειρο πλήθος διαφορετικών δυνατών τιμών (π.χ. ηλικία διδάσκοντος, βάρος μαθητή).</li>
</ul>
<p>Στην περίπτωση των συνεχών μεταβλητών (σε αντίθεση με τις διακριτές μεταβλητές), είναι πολύ σπάνιο να μετρήσουμε την ίδια τιμή πολλές φορές σε ένα δείγμα που έχουμε συλλέξει. Αν παρατηρήσουμε κάτι τέτοιο για μία συνεχή μεταβλητή που μετρήσαμε, τότε θα πρέπει να αναθεωρήσουμε τον τρόπο μέτρησης της μεταβλητής ή να επανεξετάσουμε αν η εν λόγω μεταβλητή είναι πράγματι συνεχής. Τέλος, καθώς η ακρίβεια των εργαλείων που έχουμε για την μέτρηση των συνεχών μεταβλητών δεν είναι τέλεια, θα πρέπει να αντιμετωπίζουμε τις τιμές των συνεχών μεταβλητών περισσότερο ως διαστήματα και λιγότερο ως απόλυτες τιμές. Για παράδειγμα, αν το βάρος δύο μαθητών μίας τάξης νηπιαγωγείου μετρηθεί ως 19 kg, δεν είναι λογικό να υποθέσουμε ότι οι μαθητές έχουν το ίδιο ακριβώς βάρος. Το πιο σωστό θα ήταν να θεωρήσουμε ότι και οι δύο μαθητές έχουν ένα βάρος μεταξύ π.χ. 18.5 και 19.5 κιλών. Το εύρος του διαστήματος αυτού εξαρτάται κατά κύριο λόγο από την ακρίβεια της ζυγαριάς που χρησιμοποιήθηκε.</p>
</section>
<section id="κλίμακες-μέτρησης-μεταβλητών" class="level2">
<h2 class="anchored" data-anchor-id="κλίμακες-μέτρησης-μεταβλητών">Κλίμακες μέτρησης μεταβλητών</h2>
<p>Η συλλογή των τιμών μίας μεταβλητής που παρατηρούνται σε ένα δείγμα με τον έναν ή τον άλλον τρόπο προϋποθέτει τη μέτρηση με τη χρήση κάποιας κλίμακας. Για παράδειγμα, το ύψος των μαθητών μίας τάξης μπορεί να μετρηθεί είτε χρησιμοποιώντας τις κατηγορίες κοντός, μέτριος, ψηλός (διακριτή μεταβλητή) ή να μετρηθεί με ακρίβεια εκατοστού (συνεχής μεταβλητή). Οι κλίμακες μέτρησης έχουν μεγάλη σημασία γιατί επηρεάζουν τις στατιστικές μεθόδους που μπορούν να χρησιμοποιηθούν για την ανάλυσή τους.</p>
<p>Η <em>ονομαστική κλίμακα</em> ορίζει ως επιτρεπόμενες τιμές μίας μεταβλητής τα <em>ονόματα</em> διακριτών κατηγοριών. Οι κατηγορίες αυτές δεν μπορούν να διαταχθούν, δηλαδή δεν μπορούμε να συγκρίνουμε τη μία τιμή με την άλλη. Αν και οι κατηγορίες δεν είναι αριθμητικές μπορεί να παρουσιαστούν με αριθμητικές τιμές, π.χ. μπορεί να χρησιμοποιηθεί ο αριθμός 1 για να δηλώσει ως τόπο κατοικίας του μαθητή τον δήμο Φλώρινας και ο αριθμός 2 για να δηλώσει τον δήμο Καστορίας, χωρίς αυτό όμως να υποδηλώνει κάποια διάταξη για τους δύο δήμους.</p>
<p>Αντίθετα, σε μία <em>διατάξιμη κλίμακα</em> οι κατηγορίες παίρνουν τιμές η οποίες υποδηλώνουν διάταξη. Για παράδειγμα, η οικονομική κατάσταση του σπιτικού των μαθητών μίας τάξης θα μπορούσε να μετρηθεί χρησιμοποιώντας τις τιμές χαμηλή, μέτρια, υψηλή. Οι τιμές παρόλο που επιτρέπουν τη σύγκριση μεταξύ των μετρήσεων του δείγματος, δεν επιτρέπουν συμπεράσματα για το μέγεθος των διαφορών.</p>
<p>Τέλος, μεταβλητές που μετρήθηκαν χρησιμοποιώντας την <em>ισοδιαστημική κλίμακα</em> ή την <em>αναλογική κλίμακα</em> επιτρέπουν την εξαγωγή συμπερασμάτων σχετικά με τη διάταξη του δείγματος. Οι τιμές μίας μεταβλητής μετρημένης με μία <em>ισοδιαστημική κλίμακα</em> ιεραρχούνται και ταυτόχρονα τα διαστήματα μεταξύ διαδοχικών τιμών είναι σταθερά και τα ίδια. Για παράδειγμα, η θερμοκρασία μίας αίθουσας τους καλοκαιρινούς μήνες.</p>
<p>Η βασική διαφορά μίας ισοδιαστημικής κλίμακας από μία αναλογική κλίμακα, είναι ότι στην πρώτη περίπτωση η τιμή 0 είναι αυθαίρετη. Για παράδειγμα, δεν μπορούμε να πούμε ότι για δύο μετρήσεις θερμοκρασίας 20 και 40 βαθμών Κελσίου, η πρώτη είναι διπλάσια από την δεύτερη. Αν άλλη κλίμακα είχε χρησιμποιηθεί (π.χ. Fahrenheit) τότε ο λόγος των τιμών θα ήταν διαφορετικός. Σε μία <em>αναλογική κλίμακα</em>, το 0 έχει σημασία και υποδηλώνει απουσία. Η ύπαρξη ενός απόλυτου 0, υποδηλώνει ότι μπορούμε να μετρήσουμε το απόλυτο μέγεθος της μεταβλητής. Για παράδειγμα ύψος ίσο με 0 σημαίνει απουσία ύψους και ύψος 120 εκατοστών είναι διπλάσιο από το ύψος 60 εκατοστών. Το 0 σε αυτήν την περίπτωση δεν είναι σχετικό, αλλά απόλυτο. Επομένως, η αναλογική κλίμακα είναι μία ισοδιαστημική κλίμακα με την ύπαρξη ενός απόλυτου μηδέν.</p>
</section>
<section id="μαθηματικοί-συμβολισμοί" class="level2">
<h2 class="anchored" data-anchor-id="μαθηματικοί-συμβολισμοί">Μαθηματικοί συμβολισμοί</h2>
<p>Συνήθως, στις στατιστικές αναλύσεις συμβολίζουμε τις τυχαίες μεταβλητές με κεφαλαία γράμματα του λατινικού αλφαβήτου. Για παράδειγμα, μπορούμε να συμβολίσουμε με <span class="math inline">\(X\)</span> το ύψος των μαθητών των νηπιαγωγείων της περιφέρειας Δυτικής Μακεδονίας. Για συγκεκριμένες μετρήσεις της μεταβλητής <span class="math inline">\(X\)</span> χρησιμοποιούμε το ίδιο <em>πεζό</em> γράμμα (<span class="math inline">\(x\)</span>). Για παράδειγμα, έστω ότι έχουμε ένα δείγμα μεγέθους <span class="math inline">\(n
= 100\)</span> από μαθητές των νηπιαγωγείων της περιφέρειας Δυτικής Μακεδονίας. Για κάθε έναν από αυτούς τους μαθητές, συμβολίζουμε την μέτρηση του ύψους με <span class="math inline">\(x_i, i = 1,\dots,100\)</span>.</p>
<p>Με τις μετρήσεις μίας μεταβλητής <span class="math inline">\(X\)</span> συνήθως θέλουμε να κάνουμε πράξεις. Μία από τις πιο συχνές ανάγκες που πορκύπτουν κατά την εκτέλεση μίας στατιστικής ανάλυσης είναι να αθροίσουμε τις τιμές <span class="math inline">\(x_i\)</span> που συλλέχθηκαν. Ο μαθηματικός συμβολισμός στην περίπτωση αυτή είναι το <span class="math inline">\(\sum\)</span>. Στο προηγούμενο παράδειγμα, το άθροισμα όλων των μετρήσεων του ύψους των 100 μαθητών θα μπορούσε να συμβολιστεί με <span class="math display">\[
\sum X = \sum_{i = 1}^{100}x_i = x_1 + x_2 +\dots + x_100
\]</span> Οι πράξεις αυτές μπορούν να γίνουν αρκετά πιο σύνθετες, π.χ. να αθροίσουμε τα τετράγωνα των μετρήσεων του ύψους (<span class="math inline">\(\sum X^2\)</span>) ή να αθροίσουμε το ύψος τους μειωμένο κατά μία μονάδα (<span class="math inline">\(\sum (X-1)\)</span>).</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>